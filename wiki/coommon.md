# Общие понятия React

**Компоненты** - элементы интерфейса, реакт позволяет удобным образом декомпозировать интерфейс на отдельные компоненты. Компоненты обычно описываются в JSX нотации в отдельных файлах в расширениями JSX.
В данном проекте все компоненты хранятся в папке components

**Функциональный компонент** - это функция возвращающая JSX

**Классовые компоненты** - это устаревший подход создания компонентов, основанный на классах и их методах. (constructor, render, this.state, постоянное использование bind)

**Двусторонне связывание** - связывание состояния со значением в инпуте (при перерисовке берется из состояния, при изменении вызывается коллбэк изменяющий состояние)
**Управляемые компонеты** - компоненты которые можно изменять изменяя связанное с ними состояние.

```jsx
<imput value={value} onChange={(e) => setValue(e.target.value)} />
```

## Особенности синтаксиса JSX

- **className** (вместо class)

```jsx
<div className="post"></div>
<div className={styles.postStyle}></div> // если используется выражение кавычки не ставятся
```

**Инлайновый импорт CSS** при использовании сборщиков активно применяют внедрение CSS прямо в код HTML инлайново, для этого необходимо просто добавить import 'path/to/css-file' например в App.jsx после чего сборщик внедрит стиль инлайново.

**Интерполяция** в JSX активно используется интерполяция. Когда в JSX разметку требуется вставить код на JS используются {} если требуется вставить объект то соответственно {{}}

**props** - пропсы это имя переменной используемое по соглашению для передачи данных в компоненты для того, чтобы сделать их динамическими.

**Создание в JSX списков компонетов из массивов**

```jsx
// подготовка данных для последующего рендеринга
const [posts, setPosts] = useState([
    { id: 1, title: 'JavaScript 1', body: 'Description' },
    { id: 2, title: 'JavaScript 2', body: 'Description' },
    { id: 3, title: 'JavaScript 3', body: 'Description' },
  ]);

  ...

// маппинг данных на компоненты. Реакт автоматически объединяет массив в единую строку с JSX (не забываем про key)
{posts.map(post => <PostItem key={post.id} post={post}></PostItem>)}
```

При создании массивов для выполения React работы по оптимизации ренедеринга он требует указывать для всех элементов создаваемых из массива свойство key содержащее уникальных идентификтор.

**Инлайновые стили в JSX**
Для вставки инлайнового стиля в JSX используется следующая конструкция:

```jsx
<h1 style={{ textAlign: "center" }}>Список постов</h1>
```

Стиль вставляется в виде объекта со свойствами соответствующими именам свойств, поэтому для имена свойств задаются в camalCase

**{props.children} пропс children, разворачивание ...props, передача полей типа disabled**

> :warning: запись {props.children}

размещенная в рендере компонента передает на рендер все вложение этого компонента заданное непосредственно при применении компонента в JSX
В параметрах функционального компонента записывают

```jsx
({ children, ...props });
```

> :warning: ...otherProps

Это позволяет выделить отдельно необходимый пропс children, а все оставшиеся переданные props свойства собрать в объект props или например можно развать его ...othersProps. Данный объект в дальнейшем можно или дестуктурировать для использования или передать в виде пропсов в другой вложенный компонент предаварительно разложив его ...spred оператором. например

```jsx
<SomeInnerComponent {...otherProps}>content</SomeInnerComponent>
```

> :warning: disabled и другие подобные поля

Это очень удобно для передачи стандартных свойств типа disabled для button, это будет выглядеть так.

```jsx
// передача параметра disabled
<MyButton disabled>Создать пост</MyButton>;

// использование параметра disabled и других стандартных
export default function MyButton({ children, ...props }) {
  return (
    <button className={classes.myBtn} {...props}>
      {children}
    </button>
  );
}
```

## Два подхода к обработке событий в React

1. **Через управляемые компоненты useState**
   Используя двойное связывание и useState
2. **Через неуправляемые компонеты useRef**
   Смотри описание Хука useRef
   В этом случае DOM элемент сам выполняет роль стейта
   В этом случае, если ссылка передается в кастомный компонент, то требуется использовать обертку useRef.

## Объединение нескольких стейтвов в один стейт объект и его изменение

Например заменям два стейта одним:
// const [title, setTitle] = useState('');
// const [body, setBody] = useState('');

```jsx
// инициализируем объект в случае необходимости
const [post, setPost] = useState({ title: "", body: "" });

...

// изменения в объекте стейта делаются пересборкой объекта с точечным затиранием требуемого свойства
postSet({...post, title: e.target.value})
```

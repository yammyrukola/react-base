# Общие понятия React

**Компоненты** - элементы интерфейса, реакт позволяет удобным образом декомпозировать интерфейс на отдельные компоненты. Компоненты обычно описываются в JSX нотации в отдельных файлах в расширениями JSX.
В данном проекте все компоненты хранятся в папке components

**Функциональный компонент** - это функция возвращающая JSX

**Классовые компоненты** - это устаревший подход создания компонентов, основанный на классах и их методах. (constructor, render, this.state, постоянное использование bind)

**Двусторонне связывание** - связывание состояния со значением в инпуте (при перерисовке берется из состояния, при изменении вызывается коллбэк изменяющий состояние)
**Управляемые компонеты** - компоненты которые можно изменять изменяя связанное с ними состояние.

```jsx
<imput value={value} onChange={(e) => setValue(e.target.value)} />
```

## Особенности синтаксиса JSX

- **className** (вместо class)

```jsx
<div className="post"></div>
<div className={styles.postStyle}></div> // если используется выражение кавычки не ставятся
```

**Инлайновый импорт CSS** при использовании сборщиков активно применяют внедрение CSS прямо в код HTML инлайново, для этого необходимо просто добавить import 'path/to/css-file' например в App.jsx после чего сборщик внедрит стиль инлайново.

**Интерполяция** в JSX активно используется интерполяция. Когда в JSX разметку требуется вставить код на JS используются {} если требуется вставить объект то соответственно {{}}

**props** - пропсы это имя переменной используемое по соглашению для передачи данных в компоненты для того, чтобы сделать их динамическими.

**Создание в JSX списков компонетов из массивов**

```jsx
// подготовка данных для последующего рендеринга
const [posts, setPosts] = useState([
    { id: 1, title: 'JavaScript 1', body: 'Description' },
    { id: 2, title: 'JavaScript 2', body: 'Description' },
    { id: 3, title: 'JavaScript 3', body: 'Description' },
  ]);

  ...

// маппинг данных на компоненты. Реакт автоматически объединяет массив в единую строку с JSX (не забываем про key)
{posts.map(post => <PostItem key={post.id} post={post}></PostItem>)}
```

При создании массивов для выполения React работы по оптимизации ренедеринга он требует указывать для всех элементов создаваемых из массива свойство key содержащее уникальных идентификтор.

**Инлайновые стили в JSX**
Для вставки инлайнового стиля в JSX используется следующая конструкция:

```jsx
<h1 style={{ textAlign: "center" }}>Список постов</h1>
```

Стиль вставляется в виде объекта со свойствами соответствующими именам свойств, поэтому для имена свойств задаются в camalCase

**{props.children} пропс children, разворачивание ...props, передача полей типа disabled**

> :warning: запись {props.children}

размещенная в рендере компонента передает на рендер все вложение этого компонента заданное непосредственно при применении компонента в JSX
В параметрах функционального компонента записывают

```jsx
({ children, ...props });
```

> :warning: ...otherProps

Это позволяет выделить отдельно необходимый пропс children, а все оставшиеся переданные props свойства собрать в объект props или например можно развать его ...othersProps. Данный объект в дальнейшем можно или дестуктурировать для использования или передать в виде пропсов в другой вложенный компонент предаварительно разложив его ...spred оператором. например

```jsx
<SomeInnerComponent {...otherProps}>content</SomeInnerComponent>
```

> :warning: disabled и другие подобные поля

Это очень удобно для передачи стандартных свойств типа disabled для button, это будет выглядеть так.

```jsx
// передача параметра disabled
<MyButton disabled>Создать пост</MyButton>;

// использование параметра disabled и других стандартных
export default function MyButton({ children, ...props }) {
  return (
    <button className={classes.myBtn} {...props}>
      {children}
    </button>
  );
}
```

---

## Два подхода к обработке событий в React

1. **Через управляемые компоненты useState**
   Используя двойное связывание и useState
2. **Через неуправляемые компонеты useRef**
   Смотри описание Хука useRef
   В этом случае DOM элемент сам выполняет роль стейта
   В этом случае, если ссылка передается в кастомный компонент, то требуется использовать обертку useRef.

## Объединение нескольких стейтвов в один стейт объект и его изменение

Например заменям два стейта одним:
// const [title, setTitle] = useState('');
// const [body, setBody] = useState('');

```jsx
// инициализируем объект в случае необходимости
const [post, setPost] = useState({ title: "", body: "" });

...

// изменения в объекте стейта делаются пересборкой объекта с точечным затиранием требуемого свойства
postSet({...post, title: e.target.value})
```

## Передача колбека для изменения стейта вниз по иерарахии

Т.к. передача пропса процесс однонаправленный, то если надо изменить стейт вышестоящего компонента, то вместо передачи новых пропсов вверх, что невозможно, нужно передать в нижестоящие компоненты callback который будет вызываться этими компонентами и будет менять стейт вышестоящего компонента.

## Изменение массивов в React

    - добавление нового элемента:
      **setPosts([posts, ...]);**
    - удаление элемента:
      **setPosts(posts.filter(p => p.id !== post.id));**
    - сортировка (немутабельная c предварительным копированием массива):
      **setPosts([...posts].sort((a, b) => a[sort].localCompare(b[sort])))**

## Условная отрисовка:

пример:

```jsx
{
  posts.length ? (
    <PostList remove={removePost} posts={posts} title="Список постов" />
  ) : (
    <h1 style={{ textAlign: "center" }}>Посты не найдены!</h1>
  );
}
```

## Сортировка

```js
const getSortedPosts = () => {
  console.log("Отработала getSortedPosts"); // для наглядности работы useMemo
  if (selectedSort) {
    return [...posts].sort((a, b) =>
      a[selectedSort].localeCompare(b[selectedSort])
    );
  }
  return posts;
};

const sortedPosts = useMemo(getSortedPosts, [selectedSort, posts]);
```

## Фильтрация

```js
const sortedAndSearchPosts = useMemo(() => {
  return sortedPosts.filter(
    (post) => post.title.toLowerCase().includes(searchQuery.toLowerCase()),
    [searchQuery, sortedPosts]
  );
});
```

## Модальные окна в реакте

:warning: рассмотрен вариант работы с модификтором active в module css
через использование массива с классами и их объединение

```jsx
const rootClasses = [cl.myModal];
if (visible) {
  rootClasses.push(cl.active);
}

<div className={rootClasses.join(" ")} onClick={() => setVisible(false)}>
```

:warning: для модальных окон так же может быть интересен метод **event.stopPropagation()** чтобы предотвратить обработку клика по контентной области которая приводит к закрытию окна.
